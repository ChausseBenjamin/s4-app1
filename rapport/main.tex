\documentclass[a11paper]{article}

\usepackage{karnaugh-map}
\usepackage{tabularx}
\usepackage{titlepage}
\usepackage{document}
\usepackage{booktabs}
\usepackage{multicol}
\usepackage{float}
\usepackage{varwidth}
\usepackage{graphicx}
% \usepackage[toc,page]{appendix}
\usepackage[usenames,dvipsnames]{xcolor}

\title{Rapport d'APP}

\class{Logique Combinatoire}
\classnb{GEN420 \& GEN430}

\teacher{Marwan Besrour \& Gabriel Bélanger}

\author{
  \addtolength{\tabcolsep}{-0.4em}
  \begin{tabular}{rcl} % Ajouter des auteurs au besoin
      Benjamin Chausse & -- & CHAB1704 \\
      Shawn Couture    & -- & COUS1912 \\
  \end{tabular}
}

\newcommand{\todo}[1]{\begin{color}{Red}\textbf{TODO:} #1\end{color}}
\newcommand{\note}[1]{\begin{color}{Orange}\textbf{NOTE:} #1\end{color}}
\newcommand{\fixme}[1]{\begin{color}{Fuchsia}\textbf{FIXME:} #1\end{color}}
\newcommand{\question}[1]{\begin{color}{ForestGreen}\textbf{QUESTION:} #1\end{color}}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\todo{test} \fixme{another test} \note{interesting} \question{wtf}

\section{Module thermo2bin}

\subsection{Démarche et équations}
Le but était de convertir un code thermométrique de 12 bits en binaire 4 bits non signé. Hors, le nombre afficher par ce genre de code
est connue en comptant le nombre de bits à un. Donc, les équations logiques doivent compter le nombre de bit à 1. Le code étant 12 bits,
il a pu être divisé en trois sections de 4 bits ce qui a permis l'utilisation de tableaux de Karnaugh pour trouver les équations. Selon
la table de vérité (\todo{\ref{tab:table-de-vérité-thermométrique-4-bits}}) d'un code thermométrique de 4 bits, le bit le plus significatif
du résultat en binaire n'est jamais à 1. L'équation du bit $E$ est donc simplement $E=0$. Le bit $F$ est uniquement à 1 si $A$ est à un, donc
l'équation est simplement $F=A$. On a donc besoin des tables pour uniquement deux bits des 4. Les deux tables de karnaugh pour chaque bits
se retrouvent dans l'annexe (\todo{\ref{tab:karnaugh-bit-G}}, \todo{\ref{tab:karnaugh-bit-H}}). Uniquement l'équation du bit $H$ à eut une
simplification ou $A'$ à été mis en évidence. Les équations étant assez simplifié sont les suivantes:

\begin{align}
  E &= 0 \\ F &= A \\ G &= A'C \\ H &= C'D+A'B
\end{align}

Après, les trois nombre binaires sont additionner ensemble pour obtenir un résultat correspondant au nombre de bits à 1 dans le code
thermométrique en utilisant des additionneur 4 bits. Pour ce qui est du code d'erreur, une validation par groupe de 2 bits qui s'occuppe
de s'assurer que le "LSB" n'est pas à 0 si le "MSB" est à un, sur tout les groupe de 2 bits consécutif permet de savoir rapidement s'il
y a des erreurs. (voir le code en annexe).

\subsection{Explication des schéma blocs}
Thermo2bin est composé de deux additionneur 4 bits, lesquels sont composé de 4 additionneur 1 bits. L'additionneur 1 bit fait avec de la
logique combinatoire et celui fait avec des commandes "cases" sont synthéthisé par Vivado et donne le même circuit. On retrouve dans le
module thermométrique 3 sections identiques de convertions thermométrique 4 bits en binaire non signé. Le module thermométrique à aussi
une section de détection d'erreur qui prend l'entrée directement. Notez que Vivado optimize certains modules avec des "look-up" tables
afin de les rendre plus rapide qu'uniquement des portes logiques brute.

\subsection{Fréquence d'opération}
Pour connaitre la fréquence d'opération maximum, on doit d'abord analyzer le schéma et trouver le plus long chemin qu'une entrée peut
parcourir avant d'arrivé à la sortie. Ceci peut être fait en regardant simplement les schémas créé par Vivado.
\\
Le plus long chemin interne d'un additionneur 1 bit est entre les bits d'entrées et le "carry-out", un total de $3$ portes logiques pour 
le premier additionneur 1 bits. Apres, tout les additionneur 1 bit font une chaine  de "carry-in" à "carry-out" qui prend $2$ portes
logiques. l'additionneur 4 bits a utilisé 4 additionneur d'un bit. Le plus long chemin de celui-ci est visible 
dans le schéma de l'annexe et est le "daisy-chain" entre le "carry-in" et le "carry-out", qui donne un total de 4 additionneur 1 bit à 
passer au travers. Donc $2\times4+1=9$ portes logiques pour l'additionneur 4 bits. Le module thermo2bin à 2 additionneur 4 bits dans lequel 
un "carry-in" peut se propager. Le deuxième additionneur de 4 bits utiliserait $8$ portes logiques car son entrée est le 
"carry-out" de l'additionneur d'avant. Donc $17$ portes logique. Pour l'entrée du thermo2bin, le bit avec le plus de porte logique pour son 
calcul est le $H$. Avec le chemin suivant: $C'\rightarrow(C'D)\rightarrow(C'D)+(A'B)$, qui résulte en $3$ portes logique 
de plus. le total est donc environ $20$ porte logique.
\\
On indique un temps de propagation de $5ns$. Le temps de propagation maximum possible est donc environ $20\times5=100ns$. Sans ajouter de
temps de lecture, et sans prendre en compte les "buffers" ajouter par Vivado sur les entrés et sorties, la fréquence en Hertz est donc 
très approximativement la suivante:

\begin{align}
  10000000 \approx \frac{1}{100\times10^{-9}}
\end{align}

$10\text{Mhz}$ est loin du $20\text{Mhz}$ demandé. Cependant, Vivado a optimiser l'additionneur d'un bit avec des "look-up tables",
réduisant le circuit logique de $3$ maximum à $1$, pour un total d'environ $11$ au lieu de $20$. Cependant, ce n'est toujours pas
suffisant ($18\text{Mhz}$).

\begin{align}
  18181818 \approx \frac{1}{(11\times5)\times10^{-9}}
\end{align}

\subsection{Implémentation}
Le code VHDL du thermo2bin est donnée dans l'annexe. 3 composantes sont utilisées de façon hiérarchique. Le module thermo2bin aurait pu
être diviser en sous-modules de 4 bits mais à des fin d'optimisation, les trois conversion de segments de 4 bits thermométrique sont tous
dans le même module. Au début, après le begin, on retrouve 3 sections quasi identiques. Ces dernières performent les équations booléaine
de convertions sur les segments de 4 bits en provenance du vecteur thermométrique de 12 bits. Les résultats sont mis dans 3 signaux,
lesquels sont additionner avec l'additionneur 4 bits un par un. Le résultat du premier plus le deuxième est additionner par la suite avec
le troisième. Un signaux de "carry" permet de lier les deux additionneur ensemble. Le résultat de l'addition est mise en sortie du module
thermo2bin. La détection d'erreur suit à la fin du code. Cette dernière à été expliquer dans la section de démarche.
\\
Le code VHDL de l'additionneur de 4 bits est simple. 4 composantes d'additionneur 1 bits sont instancié. Des signaux permettent de
transmettre les "carry" d'un additionneur à un autre, de même pour les signaux d'additions qui permettent d'additionner chaque bits des
deux nombre de 4 bits ensemble. Le premier module additionne les "LSB" ensemble et donne le "carry" à l'additionneur suivant, qui additionne
les bits à la position 1 ensemble, ainsi de suite.
\\
Les additionneurs 1 bits son simple et sont le résultat d'une table de vérité de laquel une expression booléaine à été construite.

\section{Simulation Complète}
Tout les modules du projet ont leurs propre test bench avec leurs tests unitaire. Par conséquent, le testbench de AppCombiTop n'a pas
tout les tests de 7 segments. Il test que les boutons changent les deux DELs de parité et que l'entrée ADCth change les DELs PMOD.
Le testbench de Thermo2bin test tout les cas de figure valide et quelques tests invalide. Les autres testbench testent les modules
individuellement pour tout les cas de figure ou presque tout. Il était donc redondant et trop long de refaire tout ces tests unitaire la
dans le test bench d'AppCombiTop, car une duplication des fonctionalitées testé aurait lieux.
\\
Le banc de test du Mux ne tests pas toutes les possibilitées. Étant donnée qu'il est composé de 3 autres composantes lesquels ont leurs
propre banc de tests, cela aurait créé des tests redondant. Le banc de test du Mux test les combinaisons de boutons donnant une erreur,
s'assure que celle-ci est envoyé aux 7 segments, que l'erreur en entrée fonctionne, et que toutes combinaisons de boutons valide affiche
les bon nombre sur les 7 segments en sortie. Il test aussi la présence du Moin 5 sur la sortie signée.
\\
Le test de thermo2bin n'a pas besoin de tester les $2^{12}$ possibilité. Il suffit de tester les $12$ valide puis de tester que la
détection d'erreur fonctionne sur toutes les paires de $2$ bits. Ensuite, quelques tests avec plusieurs zéros aléatoire sont effectué
juste pour confirmé.
\\
Les banc de tests utilisent des "assert" qui permet d'afficher dans le terminal si des problèmes ont eut lieux (résultat obtenu diffère
du résultat voulu). La plus part fonctionne parfaitement tandis que d'autre montre quelques problèmes liés aux "undefined" qui causent des
affichage d'erreur incohérent tel que: "Obtenu 0 Voulu 0". Un autre cas est celui de Thermo2bin qui montre un décalage de 1 dans le
graphique des 12 bits thermométrique par rapport aux résultat obtenu et voulu malgrés le bon fonctionnement du module.

\section{Démarche d'analyse de compatibilité}
La première étape à été d'analyser le signal d'entrée de la carte thermométrique. La DEL 2 est connecté au connecteur JD1 en
configuration "pull-up". Ceci dit, il faut donc avoir un 0 logique à son entrée pour l'allumé. Cependant, trois inverseurs sont
connecté en série avant elle. Soit deux 74V1T04STR et un NC7SP04P5X alimenté à +1.2 Volts. Après analyse de $V_{OH}$, $V_{OL}$, $V_{IL}$
et $V_{IH}$ des deux portes logiques, le NC7SP04P5X à un $V_{OH}$ de maximum 1.1 volts tandis que le 74V1T04STR à besoin d'un $V_{IH}$
minimum de 2 Volts. Donc selon le 74V1T04STR, le NC7SP04P5X envoie toujours un niveau logique bas, ce qui résulte à une del
tout le temps allumé sauf lorsque le connecteur de test de la del est en mode de test car un bon niveau logique haut est envoyé à
l'entrée des 74V1T04STR.

\input{annexe.tex}
\end{document}
